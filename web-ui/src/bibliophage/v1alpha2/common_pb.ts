// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file bibliophage/v1alpha2/common.proto (package bibliophage.v1alpha2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * SortOrder defines common sorting options
 *
 * @generated from enum bibliophage.v1alpha2.SortOrder
 */
export enum SortOrder {
  /**
   * Default sorting
   *
   * @generated from enum value: SORT_ORDER_UNSPECIFIED = 0;
   */
  SORT_ORDER_UNSPECIFIED = 0,

  /**
   * @generated from enum value: NAME_ASC = 1;
   */
  NAME_ASC = 1,

  /**
   * @generated from enum value: NAME_DESC = 2;
   */
  NAME_DESC = 2,

  /**
   * @generated from enum value: CREATED_AT_ASC = 3;
   */
  CREATED_AT_ASC = 3,

  /**
   * @generated from enum value: CREATED_AT_DESC = 4;
   */
  CREATED_AT_DESC = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(SortOrder)
proto3.util.setEnumType(SortOrder, "bibliophage.v1alpha2.SortOrder", [
  { no: 0, name: "SORT_ORDER_UNSPECIFIED" },
  { no: 1, name: "NAME_ASC" },
  { no: 2, name: "NAME_DESC" },
  { no: 3, name: "CREATED_AT_ASC" },
  { no: 4, name: "CREATED_AT_DESC" },
]);

/**
 * Tag represents a named category with multiple values
 * Example: {"name": "genre", "values": ["adventure", "fantasy", "noire"]}
 *
 * @generated from message bibliophage.v1alpha2.Tag
 */
export class Tag extends Message<Tag> {
  /**
   * Name of the tag (e.g., "genre", "world", "category", "tone")
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Values associated with this tag
   *
   * @generated from field: repeated string values = 2;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<Tag>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.Tag";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tag {
    return new Tag().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tag {
    return new Tag().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tag {
    return new Tag().fromJsonString(jsonString, options);
  }

  static equals(a: Tag | PlainMessage<Tag> | undefined, b: Tag | PlainMessage<Tag> | undefined): boolean {
    return proto3.util.equals(Tag, a, b);
  }
}

/**
 * TagFilter represents a filter for tag-based searches
 * Matches items where tag.name == name AND any value in tag.values matches value
 *
 * @generated from message bibliophage.v1alpha2.TagFilter
 */
export class TagFilter extends Message<TagFilter> {
  /**
   * Name of the tag to filter on (e.g., "genre", "campaign")
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Value to match within the tag (e.g., "fantasy", "core-rules")
   *
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<TagFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.TagFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TagFilter {
    return new TagFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TagFilter {
    return new TagFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TagFilter {
    return new TagFilter().fromJsonString(jsonString, options);
  }

  static equals(a: TagFilter | PlainMessage<TagFilter> | undefined, b: TagFilter | PlainMessage<TagFilter> | undefined): boolean {
    return proto3.util.equals(TagFilter, a, b);
  }
}

