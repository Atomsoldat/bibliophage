// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file bibliophage/v1alpha2/pdf.proto (package bibliophage.v1alpha2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { SortOrder, Tag, TagFilter } from "./common_pb.js";

/**
 * Pdf represents a PDF document in the system
 * Does not actually contain the raw data, only metadata
 *
 * @generated from message bibliophage.v1alpha2.Pdf
 */
export class Pdf extends Message<Pdf> {
  /**
   * Unique identifier for this PDF (assigned by the system)
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Human-readable name (e.g., "Monster Manual", "Player's Handbook")
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Which RPG system this belongs to (e.g., "D&D 5e", "Pathfinder 2e")
   *
   * @generated from field: string system = 3;
   */
  system = "";

  /**
   * Type of publication (e.g., "Core Rulebook", "Adventure", "Supplement")
   *
   * @generated from field: string type = 4;
   */
  type = "";

  /**
   * Number of pages in the PDF
   *
   * @generated from field: int32 page_count = 5;
   */
  pageCount = 0;

  /**
   * Original filesystem path (where it was loaded from)
   *
   * @generated from field: string origin_path = 6;
   */
  originPath = "";

  /**
   * When this PDF was first loaded into the system
   *
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: Timestamp;

  /**
   * When this PDF was last updated
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 8;
   */
  updatedAt?: Timestamp;

  /**
   * File size in bytes
   *
   * @generated from field: int64 file_size = 9;
   */
  fileSize = protoInt64.zero;

  /**
   * Number of chunks this PDF was split into
   *
   * @generated from field: int32 chunk_count = 10;
   */
  chunkCount = 0;

  /**
   * Structured tags for organization (name + multiple values)
   *
   * @generated from field: repeated bibliophage.v1alpha2.Tag tags = 11;
   */
  tags: Tag[] = [];

  constructor(data?: PartialMessage<Pdf>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.Pdf";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "system", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "page_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "origin_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "created_at", kind: "message", T: Timestamp },
    { no: 8, name: "updated_at", kind: "message", T: Timestamp },
    { no: 9, name: "file_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "chunk_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 11, name: "tags", kind: "message", T: Tag, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pdf {
    return new Pdf().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pdf {
    return new Pdf().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pdf {
    return new Pdf().fromJsonString(jsonString, options);
  }

  static equals(a: Pdf | PlainMessage<Pdf> | undefined, b: Pdf | PlainMessage<Pdf> | undefined): boolean {
    return proto3.util.equals(Pdf, a, b);
  }
}

/**
 * PdfListItem represents a PDF in list/search results
 * Contains metadata only - never includes the actual PDF file data
 * Structurally identical to Pdf, but semantically distinct for search responses
 * This separation ensures future changes to search results don't affect other operations
 *
 * @generated from message bibliophage.v1alpha2.PdfListItem
 */
export class PdfListItem extends Message<PdfListItem> {
  /**
   * Unique identifier for this PDF
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Human-readable name
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Which RPG system this belongs to
   *
   * @generated from field: string system = 3;
   */
  system = "";

  /**
   * Type of publication
   *
   * @generated from field: string type = 4;
   */
  type = "";

  /**
   * Number of pages in the PDF
   *
   * @generated from field: int32 page_count = 5;
   */
  pageCount = 0;

  /**
   * Original filesystem path (where it was loaded from)
   *
   * @generated from field: string origin_path = 6;
   */
  originPath = "";

  /**
   * When this PDF was first loaded into the system
   *
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: Timestamp;

  /**
   * When this PDF was last updated
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 8;
   */
  updatedAt?: Timestamp;

  /**
   * File size in bytes
   *
   * @generated from field: int64 file_size = 9;
   */
  fileSize = protoInt64.zero;

  /**
   * Number of chunks this PDF was split into
   *
   * @generated from field: int32 chunk_count = 10;
   */
  chunkCount = 0;

  /**
   * Structured tags for organization
   *
   * @generated from field: repeated bibliophage.v1alpha2.Tag tags = 11;
   */
  tags: Tag[] = [];

  constructor(data?: PartialMessage<PdfListItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.PdfListItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "system", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "page_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "origin_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "created_at", kind: "message", T: Timestamp },
    { no: 8, name: "updated_at", kind: "message", T: Timestamp },
    { no: 9, name: "file_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "chunk_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 11, name: "tags", kind: "message", T: Tag, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PdfListItem {
    return new PdfListItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PdfListItem {
    return new PdfListItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PdfListItem {
    return new PdfListItem().fromJsonString(jsonString, options);
  }

  static equals(a: PdfListItem | PlainMessage<PdfListItem> | undefined, b: PdfListItem | PlainMessage<PdfListItem> | undefined): boolean {
    return proto3.util.equals(PdfListItem, a, b);
  }
}

/**
 * LoadPdfRequest - Load a PDF into the system
 *
 * @generated from message bibliophage.v1alpha2.LoadPdfRequest
 */
export class LoadPdfRequest extends Message<LoadPdfRequest> {
  /**
   * The PDF document metadata to load
   *
   * @generated from field: bibliophage.v1alpha2.Pdf pdf = 1;
   */
  pdf?: Pdf;

  /**
   * The actual PDF file data (bytes)
   *
   * @generated from field: bytes file_data = 2;
   */
  fileData = new Uint8Array(0);

  /**
   * Chunking configuration (optional parameters)
   *
   * @generated from field: bibliophage.v1alpha2.ChunkingConfig chunking_config = 3;
   */
  chunkingConfig?: ChunkingConfig;

  constructor(data?: PartialMessage<LoadPdfRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.LoadPdfRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pdf", kind: "message", T: Pdf },
    { no: 2, name: "file_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "chunking_config", kind: "message", T: ChunkingConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadPdfRequest {
    return new LoadPdfRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadPdfRequest {
    return new LoadPdfRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadPdfRequest {
    return new LoadPdfRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LoadPdfRequest | PlainMessage<LoadPdfRequest> | undefined, b: LoadPdfRequest | PlainMessage<LoadPdfRequest> | undefined): boolean {
    return proto3.util.equals(LoadPdfRequest, a, b);
  }
}

/**
 * Configuration for text chunking
 *
 * @generated from message bibliophage.v1alpha2.ChunkingConfig
 */
export class ChunkingConfig extends Message<ChunkingConfig> {
  /**
   * Size of text chunks (default: 600)
   *
   * @generated from field: int32 chunk_size = 1;
   */
  chunkSize = 0;

  /**
   * Overlap between chunks (default: 50)
   *
   * @generated from field: int32 chunk_overlap = 2;
   */
  chunkOverlap = 0;

  constructor(data?: PartialMessage<ChunkingConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.ChunkingConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunk_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "chunk_overlap", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkingConfig {
    return new ChunkingConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkingConfig {
    return new ChunkingConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkingConfig {
    return new ChunkingConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkingConfig | PlainMessage<ChunkingConfig> | undefined, b: ChunkingConfig | PlainMessage<ChunkingConfig> | undefined): boolean {
    return proto3.util.equals(ChunkingConfig, a, b);
  }
}

/**
 * LoadPdfResponse - Result of loading a PDF
 *
 * @generated from message bibliophage.v1alpha2.LoadPdfResponse
 */
export class LoadPdfResponse extends Message<LoadPdfResponse> {
  /**
   * Whether the operation succeeded
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * Human-readable status/error message
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * The loaded PDF with assigned ID and metadata
   *
   * @generated from field: bibliophage.v1alpha2.Pdf pdf = 3;
   */
  pdf?: Pdf;

  constructor(data?: PartialMessage<LoadPdfResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.LoadPdfResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "pdf", kind: "message", T: Pdf },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadPdfResponse {
    return new LoadPdfResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadPdfResponse {
    return new LoadPdfResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadPdfResponse {
    return new LoadPdfResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LoadPdfResponse | PlainMessage<LoadPdfResponse> | undefined, b: LoadPdfResponse | PlainMessage<LoadPdfResponse> | undefined): boolean {
    return proto3.util.equals(LoadPdfResponse, a, b);
  }
}

/**
 * SearchPdfsRequest - Search for PDFs by various criteria
 *
 * @generated from message bibliophage.v1alpha2.SearchPdfsRequest
 */
export class SearchPdfsRequest extends Message<SearchPdfsRequest> {
  /**
   * Search by title (partial match, case-insensitive)
   *
   * @generated from field: optional string title_query = 1;
   */
  titleQuery?: string;

  /**
   * Filter by system (exact match)
   *
   * @generated from field: optional string system_filter = 2;
   */
  systemFilter?: string;

  /**
   * Filter by type (exact match)
   *
   * @generated from field: optional string type_filter = 3;
   */
  typeFilter?: string;

  /**
   * Filter by tags (PDFs must match ALL specified tag filters)
   * Example: [{"name": "genre", "value": "fantasy"}, {"name": "campaign", "value": "storm-kings-thunder"}]
   *
   * @generated from field: repeated bibliophage.v1alpha2.TagFilter tag_filters = 4;
   */
  tagFilters: TagFilter[] = [];

  /**
   * Pagination
   *
   * Max results to return (default: 50)
   *
   * @generated from field: int32 page_size = 5;
   */
  pageSize = 0;

  /**
   * Which page of results (0-indexed)
   *
   * @generated from field: int32 page_number = 6;
   */
  pageNumber = 0;

  /**
   * Sorting (PAGE_COUNT_ASC/DESC can be added to common.proto if needed)
   *
   * @generated from field: bibliophage.v1alpha2.SortOrder sort_order = 7;
   */
  sortOrder = SortOrder.SORT_ORDER_UNSPECIFIED;

  constructor(data?: PartialMessage<SearchPdfsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.SearchPdfsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title_query", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "system_filter", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "type_filter", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "tag_filters", kind: "message", T: TagFilter, repeated: true },
    { no: 5, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "page_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "sort_order", kind: "enum", T: proto3.getEnumType(SortOrder) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchPdfsRequest {
    return new SearchPdfsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchPdfsRequest {
    return new SearchPdfsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchPdfsRequest {
    return new SearchPdfsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchPdfsRequest | PlainMessage<SearchPdfsRequest> | undefined, b: SearchPdfsRequest | PlainMessage<SearchPdfsRequest> | undefined): boolean {
    return proto3.util.equals(SearchPdfsRequest, a, b);
  }
}

/**
 * SearchPdfsResponse - Results of PDF search
 *
 * @generated from message bibliophage.v1alpha2.SearchPdfsResponse
 */
export class SearchPdfsResponse extends Message<SearchPdfsResponse> {
  /**
   * Whether the operation succeeded
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * Human-readable status/error message
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * Array of matching PDF metadata (never includes file_data)
   * To retrieve full PDF content, use GetPdf RPC with the PDF ID
   *
   * @generated from field: repeated bibliophage.v1alpha2.PdfListItem pdfs = 3;
   */
  pdfs: PdfListItem[] = [];

  /**
   * Total number of results (for pagination)
   *
   * @generated from field: int32 total_count = 4;
   */
  totalCount = 0;

  /**
   * Current page number
   *
   * @generated from field: int32 page_number = 5;
   */
  pageNumber = 0;

  /**
   * Whether there are more pages
   *
   * @generated from field: bool has_more = 6;
   */
  hasMore = false;

  constructor(data?: PartialMessage<SearchPdfsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.SearchPdfsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "pdfs", kind: "message", T: PdfListItem, repeated: true },
    { no: 4, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "page_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "has_more", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchPdfsResponse {
    return new SearchPdfsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchPdfsResponse {
    return new SearchPdfsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchPdfsResponse {
    return new SearchPdfsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchPdfsResponse | PlainMessage<SearchPdfsResponse> | undefined, b: SearchPdfsResponse | PlainMessage<SearchPdfsResponse> | undefined): boolean {
    return proto3.util.equals(SearchPdfsResponse, a, b);
  }
}

/**
 * GetPdfRequest - Retrieve a specific PDF by ID
 *
 * @generated from message bibliophage.v1alpha2.GetPdfRequest
 */
export class GetPdfRequest extends Message<GetPdfRequest> {
  /**
   * The unique ID of the PDF to retrieve
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetPdfRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.GetPdfRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPdfRequest {
    return new GetPdfRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPdfRequest {
    return new GetPdfRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPdfRequest {
    return new GetPdfRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetPdfRequest | PlainMessage<GetPdfRequest> | undefined, b: GetPdfRequest | PlainMessage<GetPdfRequest> | undefined): boolean {
    return proto3.util.equals(GetPdfRequest, a, b);
  }
}

/**
 * GetPdfResponse - Result of getting a PDF
 *
 * @generated from message bibliophage.v1alpha2.GetPdfResponse
 */
export class GetPdfResponse extends Message<GetPdfResponse> {
  /**
   * Whether the operation succeeded
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * Human-readable status/error message
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * The requested PDF (null if not found)
   *
   * @generated from field: optional bibliophage.v1alpha2.Pdf pdf = 3;
   */
  pdf?: Pdf;

  constructor(data?: PartialMessage<GetPdfResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.GetPdfResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "pdf", kind: "message", T: Pdf, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPdfResponse {
    return new GetPdfResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPdfResponse {
    return new GetPdfResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPdfResponse {
    return new GetPdfResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetPdfResponse | PlainMessage<GetPdfResponse> | undefined, b: GetPdfResponse | PlainMessage<GetPdfResponse> | undefined): boolean {
    return proto3.util.equals(GetPdfResponse, a, b);
  }
}

