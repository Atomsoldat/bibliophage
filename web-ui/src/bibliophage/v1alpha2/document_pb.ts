// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file bibliophage/v1alpha2/document.proto (package bibliophage.v1alpha2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { SortOrder, Tag, TagFilter } from "./common_pb.js";

/**
 * Enums for strict classification of data
 *
 * @generated from enum bibliophage.v1alpha2.DocumentType
 */
export enum DocumentType {
  /**
   * Default/unknown
   *
   * @generated from enum value: DOCUMENT_TYPE_UNSPECIFIED = 0;
   */
  DOCUMENT_TYPE_UNSPECIFIED = 0,

  /**
   * General notes, least specific
   *
   * @generated from enum value: NOTE = 1;
   */
  NOTE = 1,

  /**
   * Authoritative lore/world information
   *
   * @generated from enum value: LORE_FRAGMENT = 2;
   */
  LORE_FRAGMENT = 2,

  /**
   * PCs, NPCs, historical figures
   *
   * @generated from enum value: CHARACTER = 3;
   */
  CHARACTER = 3,

  /**
   * Places, regions, buildings
   *
   * @generated from enum value: LOCATION = 4;
   */
  LOCATION = 4,

  /**
   * Possessions, items, artifacts
   *
   * @generated from enum value: OBJECT = 5;
   */
  OBJECT = 5,

  /**
   * Quests, missions, plot hooks
   *
   * @generated from enum value: QUEST = 6;
   */
  QUEST = 6,

  /**
   * Session summaries, game logs
   *
   * @generated from enum value: SESSION_LOG = 7;
   */
  SESSION_LOG = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(DocumentType)
proto3.util.setEnumType(DocumentType, "bibliophage.v1alpha2.DocumentType", [
  { no: 0, name: "DOCUMENT_TYPE_UNSPECIFIED" },
  { no: 1, name: "NOTE" },
  { no: 2, name: "LORE_FRAGMENT" },
  { no: 3, name: "CHARACTER" },
  { no: 4, name: "LOCATION" },
  { no: 5, name: "OBJECT" },
  { no: 6, name: "QUEST" },
  { no: 7, name: "SESSION_LOG" },
]);

/**
 * Document represents a text document in the system
 *
 * @generated from message bibliophage.v1alpha2.Document
 */
export class Document extends Message<Document> {
  /**
   * Unique identifier for this document (assigned by the system)
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Human-readable name (e.g., "My Campaign Notes", "NPC: Elara Brightwood")
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Raw text content of the document
   *
   * @generated from field: string content = 3;
   */
  content = "";

  /**
   * Type of document (categorization)
   *
   * @generated from field: bibliophage.v1alpha2.DocumentType type = 4;
   */
  type = DocumentType.DOCUMENT_TYPE_UNSPECIFIED;

  /**
   * When this document was created
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * When this document was last updated
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 6;
   */
  updatedAt?: Timestamp;

  /**
   * Structured tags for organization (name + multiple values)
   *
   * @generated from field: repeated bibliophage.v1alpha2.Tag tags = 7;
   */
  tags: Tag[] = [];

  /**
   * Character count (for display purposes)
   *
   * @generated from field: int32 character_count = 8;
   */
  characterCount = 0;

  constructor(data?: PartialMessage<Document>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.Document";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "type", kind: "enum", T: proto3.getEnumType(DocumentType) },
    { no: 5, name: "created_at", kind: "message", T: Timestamp },
    { no: 6, name: "updated_at", kind: "message", T: Timestamp },
    { no: 7, name: "tags", kind: "message", T: Tag, repeated: true },
    { no: 8, name: "character_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Document {
    return new Document().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Document {
    return new Document().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Document {
    return new Document().fromJsonString(jsonString, options);
  }

  static equals(a: Document | PlainMessage<Document> | undefined, b: Document | PlainMessage<Document> | undefined): boolean {
    return proto3.util.equals(Document, a, b);
  }
}

/**
 * StoreDocumentRequest - Create a new document
 *
 * @generated from message bibliophage.v1alpha2.StoreDocumentRequest
 */
export class StoreDocumentRequest extends Message<StoreDocumentRequest> {
  /**
   * The document to store (ID will be assigned by server)
   *
   * @generated from field: bibliophage.v1alpha2.Document document = 1;
   */
  document?: Document;

  constructor(data?: PartialMessage<StoreDocumentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.StoreDocumentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "message", T: Document },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreDocumentRequest {
    return new StoreDocumentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreDocumentRequest {
    return new StoreDocumentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreDocumentRequest {
    return new StoreDocumentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StoreDocumentRequest | PlainMessage<StoreDocumentRequest> | undefined, b: StoreDocumentRequest | PlainMessage<StoreDocumentRequest> | undefined): boolean {
    return proto3.util.equals(StoreDocumentRequest, a, b);
  }
}

/**
 * StoreDocumentResponse - Result of storing a document
 *
 * @generated from message bibliophage.v1alpha2.StoreDocumentResponse
 */
export class StoreDocumentResponse extends Message<StoreDocumentResponse> {
  /**
   * Whether the operation succeeded
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * Human-readable status/error message
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * The stored document with assigned ID
   *
   * @generated from field: bibliophage.v1alpha2.Document document = 3;
   */
  document?: Document;

  constructor(data?: PartialMessage<StoreDocumentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.StoreDocumentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "document", kind: "message", T: Document },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreDocumentResponse {
    return new StoreDocumentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreDocumentResponse {
    return new StoreDocumentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreDocumentResponse {
    return new StoreDocumentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StoreDocumentResponse | PlainMessage<StoreDocumentResponse> | undefined, b: StoreDocumentResponse | PlainMessage<StoreDocumentResponse> | undefined): boolean {
    return proto3.util.equals(StoreDocumentResponse, a, b);
  }
}

/**
 * GetDocumentRequest - Retrieve a specific document by ID
 *
 * @generated from message bibliophage.v1alpha2.GetDocumentRequest
 */
export class GetDocumentRequest extends Message<GetDocumentRequest> {
  /**
   * The unique ID of the document to retrieve
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetDocumentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.GetDocumentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDocumentRequest {
    return new GetDocumentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDocumentRequest {
    return new GetDocumentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDocumentRequest {
    return new GetDocumentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDocumentRequest | PlainMessage<GetDocumentRequest> | undefined, b: GetDocumentRequest | PlainMessage<GetDocumentRequest> | undefined): boolean {
    return proto3.util.equals(GetDocumentRequest, a, b);
  }
}

/**
 * GetDocumentResponse - Result of getting a document
 *
 * @generated from message bibliophage.v1alpha2.GetDocumentResponse
 */
export class GetDocumentResponse extends Message<GetDocumentResponse> {
  /**
   * Whether the operation succeeded
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * Human-readable status/error message
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * The requested document (null if not found)
   *
   * @generated from field: optional bibliophage.v1alpha2.Document document = 3;
   */
  document?: Document;

  constructor(data?: PartialMessage<GetDocumentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.GetDocumentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "document", kind: "message", T: Document, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDocumentResponse {
    return new GetDocumentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDocumentResponse {
    return new GetDocumentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDocumentResponse {
    return new GetDocumentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetDocumentResponse | PlainMessage<GetDocumentResponse> | undefined, b: GetDocumentResponse | PlainMessage<GetDocumentResponse> | undefined): boolean {
    return proto3.util.equals(GetDocumentResponse, a, b);
  }
}

/**
 * UpdateDocumentRequest - Update an existing document
 *
 * @generated from message bibliophage.v1alpha2.UpdateDocumentRequest
 */
export class UpdateDocumentRequest extends Message<UpdateDocumentRequest> {
  /**
   * The document to update (must include ID)
   *
   * @generated from field: bibliophage.v1alpha2.Document document = 1;
   */
  document?: Document;

  constructor(data?: PartialMessage<UpdateDocumentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.UpdateDocumentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "message", T: Document },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDocumentRequest {
    return new UpdateDocumentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDocumentRequest {
    return new UpdateDocumentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDocumentRequest {
    return new UpdateDocumentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDocumentRequest | PlainMessage<UpdateDocumentRequest> | undefined, b: UpdateDocumentRequest | PlainMessage<UpdateDocumentRequest> | undefined): boolean {
    return proto3.util.equals(UpdateDocumentRequest, a, b);
  }
}

/**
 * UpdateDocumentResponse - Result of updating a document
 *
 * @generated from message bibliophage.v1alpha2.UpdateDocumentResponse
 */
export class UpdateDocumentResponse extends Message<UpdateDocumentResponse> {
  /**
   * Whether the operation succeeded
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * Human-readable status/error message
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * The updated document
   *
   * @generated from field: bibliophage.v1alpha2.Document document = 3;
   */
  document?: Document;

  constructor(data?: PartialMessage<UpdateDocumentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.UpdateDocumentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "document", kind: "message", T: Document },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDocumentResponse {
    return new UpdateDocumentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDocumentResponse {
    return new UpdateDocumentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDocumentResponse {
    return new UpdateDocumentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDocumentResponse | PlainMessage<UpdateDocumentResponse> | undefined, b: UpdateDocumentResponse | PlainMessage<UpdateDocumentResponse> | undefined): boolean {
    return proto3.util.equals(UpdateDocumentResponse, a, b);
  }
}

/**
 * SearchDocumentsRequest - Search for documents by various criteria
 *
 * @generated from message bibliophage.v1alpha2.SearchDocumentsRequest
 */
export class SearchDocumentsRequest extends Message<SearchDocumentsRequest> {
  /**
   * Search by name (partial match, case-insensitive)
   *
   * @generated from field: optional string name_query = 1;
   */
  nameQuery?: string;

  /**
   * Search by content (partial match, case-insensitive)
   *
   * @generated from field: optional string content_query = 2;
   */
  contentQuery?: string;

  /**
   * Filter by type (exact match)
   *
   * @generated from field: optional bibliophage.v1alpha2.DocumentType type_filter = 3;
   */
  typeFilter?: DocumentType;

  /**
   * Filter by tags (documents must match ALL specified tag filters)
   * Example: [{"name": "genre", "value": "fantasy"}, {"name": "tone", "value": "dark"}]
   * would match documents that have both genre=fantasy AND tone=dark
   *
   * @generated from field: repeated bibliophage.v1alpha2.TagFilter tag_filters = 4;
   */
  tagFilters: TagFilter[] = [];

  /**
   * Pagination
   *
   * Max results to return (default: 50)
   *
   * @generated from field: int32 page_size = 5;
   */
  pageSize = 0;

  /**
   * Which page of results (0-indexed)
   *
   * @generated from field: int32 page_number = 6;
   */
  pageNumber = 0;

  /**
   * Sorting (UPDATED_AT_ASC/DESC can be added to common.proto if needed)
   *
   * @generated from field: bibliophage.v1alpha2.SortOrder sort_order = 7;
   */
  sortOrder = SortOrder.SORT_ORDER_UNSPECIFIED;

  constructor(data?: PartialMessage<SearchDocumentsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.SearchDocumentsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name_query", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "content_query", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "type_filter", kind: "enum", T: proto3.getEnumType(DocumentType), opt: true },
    { no: 4, name: "tag_filters", kind: "message", T: TagFilter, repeated: true },
    { no: 5, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "page_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "sort_order", kind: "enum", T: proto3.getEnumType(SortOrder) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchDocumentsRequest {
    return new SearchDocumentsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchDocumentsRequest {
    return new SearchDocumentsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchDocumentsRequest {
    return new SearchDocumentsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchDocumentsRequest | PlainMessage<SearchDocumentsRequest> | undefined, b: SearchDocumentsRequest | PlainMessage<SearchDocumentsRequest> | undefined): boolean {
    return proto3.util.equals(SearchDocumentsRequest, a, b);
  }
}

/**
 * SearchDocumentsResponse - Results of document search
 *
 * @generated from message bibliophage.v1alpha2.SearchDocumentsResponse
 */
export class SearchDocumentsResponse extends Message<SearchDocumentsResponse> {
  /**
   * Whether the operation succeeded
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * Human-readable status/error message
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * Array of matching documents
   *
   * @generated from field: repeated bibliophage.v1alpha2.Document documents = 3;
   */
  documents: Document[] = [];

  /**
   * Total number of results (for pagination)
   *
   * @generated from field: int32 total_count = 4;
   */
  totalCount = 0;

  /**
   * Current page number
   *
   * @generated from field: int32 page_number = 5;
   */
  pageNumber = 0;

  /**
   * Whether there are more pages
   *
   * @generated from field: bool has_more = 6;
   */
  hasMore = false;

  constructor(data?: PartialMessage<SearchDocumentsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.SearchDocumentsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "documents", kind: "message", T: Document, repeated: true },
    { no: 4, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "page_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "has_more", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchDocumentsResponse {
    return new SearchDocumentsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchDocumentsResponse {
    return new SearchDocumentsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchDocumentsResponse {
    return new SearchDocumentsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchDocumentsResponse | PlainMessage<SearchDocumentsResponse> | undefined, b: SearchDocumentsResponse | PlainMessage<SearchDocumentsResponse> | undefined): boolean {
    return proto3.util.equals(SearchDocumentsResponse, a, b);
  }
}

/**
 * DeleteDocumentRequest - Delete a document by ID
 *
 * @generated from message bibliophage.v1alpha2.DeleteDocumentRequest
 */
export class DeleteDocumentRequest extends Message<DeleteDocumentRequest> {
  /**
   * The unique ID of the document to delete
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DeleteDocumentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.DeleteDocumentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteDocumentRequest {
    return new DeleteDocumentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteDocumentRequest {
    return new DeleteDocumentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteDocumentRequest {
    return new DeleteDocumentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteDocumentRequest | PlainMessage<DeleteDocumentRequest> | undefined, b: DeleteDocumentRequest | PlainMessage<DeleteDocumentRequest> | undefined): boolean {
    return proto3.util.equals(DeleteDocumentRequest, a, b);
  }
}

/**
 * DeleteDocumentResponse - Result of deleting a document
 *
 * @generated from message bibliophage.v1alpha2.DeleteDocumentResponse
 */
export class DeleteDocumentResponse extends Message<DeleteDocumentResponse> {
  /**
   * Whether the operation succeeded
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * Human-readable status/error message
   *
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<DeleteDocumentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bibliophage.v1alpha2.DeleteDocumentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteDocumentResponse {
    return new DeleteDocumentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteDocumentResponse {
    return new DeleteDocumentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteDocumentResponse {
    return new DeleteDocumentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteDocumentResponse | PlainMessage<DeleteDocumentResponse> | undefined, b: DeleteDocumentResponse | PlainMessage<DeleteDocumentResponse> | undefined): boolean {
    return proto3.util.equals(DeleteDocumentResponse, a, b);
  }
}

